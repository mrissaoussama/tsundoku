import eu.kanade.tachiyomi.source.model.UpdateStrategy;
import kotlin.collections.List;
import kotlin.Boolean;
import kotlin.String;

CREATE TABLE mangas(
    _id INTEGER NOT NULL PRIMARY KEY,
    source INTEGER NOT NULL,
    url TEXT NOT NULL,
    artist TEXT,
    author TEXT,
    description TEXT,
    genre TEXT AS List<String>,
    title TEXT NOT NULL,
    alternative_titles TEXT AS List<String>,
    status INTEGER NOT NULL,
    thumbnail_url TEXT,
    favorite INTEGER AS Boolean NOT NULL,
    last_update INTEGER,
    next_update INTEGER,
    initialized INTEGER AS Boolean NOT NULL,
    viewer INTEGER NOT NULL,
    chapter_flags INTEGER NOT NULL,
    cover_last_modified INTEGER NOT NULL,
    date_added INTEGER NOT NULL,
    update_strategy INTEGER AS UpdateStrategy NOT NULL DEFAULT 0,
    calculate_interval INTEGER DEFAULT 0 NOT NULL,
    last_modified_at INTEGER NOT NULL DEFAULT 0,
    favorite_modified_at INTEGER,
    version INTEGER NOT NULL DEFAULT 0,
    is_syncing INTEGER NOT NULL DEFAULT 0,
    notes TEXT NOT NULL DEFAULT "",
    is_novel INTEGER AS Boolean NOT NULL DEFAULT 0,
    -- Aggregate columns (maintained by triggers on chapters/history/mangas_categories)
    total_count INTEGER NOT NULL DEFAULT 0,
    read_count INTEGER NOT NULL DEFAULT 0,
    latest_upload INTEGER NOT NULL DEFAULT 0,
    chapter_fetched_at INTEGER NOT NULL DEFAULT 0,
    last_read INTEGER NOT NULL DEFAULT 0,
    bookmark_count INTEGER NOT NULL DEFAULT 0
);

CREATE INDEX library_favorite_index ON mangas(favorite) WHERE favorite = 1;
CREATE INDEX mangas_url_index ON mangas(url);
CREATE INDEX mangas_is_novel_index ON mangas(is_novel);

CREATE TRIGGER update_last_favorited_at_mangas
AFTER UPDATE OF favorite ON mangas
BEGIN
  UPDATE mangas
  SET favorite_modified_at = strftime('%s', 'now')
  WHERE _id = new._id;
END;

CREATE TRIGGER update_last_modified_at_mangas
AFTER UPDATE ON mangas
FOR EACH ROW
BEGIN
  UPDATE mangas
  SET last_modified_at = strftime('%s', 'now')
  WHERE _id = new._id;
END;

CREATE TRIGGER update_manga_version AFTER UPDATE ON mangas
BEGIN
    UPDATE mangas SET version = version + 1
    WHERE _id = new._id AND new.is_syncing = 0 AND (
        new.url != old.url OR
        new.description != old.description OR
        new.favorite != old.favorite
    );
END;

getMangaById:
SELECT *
FROM mangas
WHERE _id = :id;

-- TODO: this should ideally never really have more than 1 result
getMangaByUrlAndSource:
SELECT *
FROM mangas
WHERE url = :url
AND source = :source
LIMIT 1;

getLiteMangaByUrlAndSource:
SELECT
    _id,
    source,
    url,
    NULL AS artist,
    NULL AS author,
    NULL AS description,
    NULL AS genre,
    title,
    NULL AS alternative_titles,
    0 AS status,
    thumbnail_url,
    favorite,
    last_update,
    next_update,
    0 AS initialized,
    0 AS viewer,
    0 AS chapter_flags,
    cover_last_modified,
    date_added,
    0 AS update_strategy,
    0 AS calculate_interval,
    0 AS last_modified_at,
    NULL AS favorite_modified_at,
    0 AS version,
    0 AS is_syncing,
    '' AS notes,
    0 AS is_novel
FROM mangas
WHERE url = :url
AND source = :source
LIMIT 1;

getFavorites:
SELECT *
FROM mangas
WHERE favorite = 1;

getFavoritesEntry:
SELECT _id, source, url, title, artist, author, thumbnail_url, cover_last_modified, favorite, is_novel
FROM mangas
WHERE favorite = 1;

getFavoritesEntryBySourceId:
SELECT _id, source, url, title, artist, author, thumbnail_url, cover_last_modified, favorite, is_novel
FROM mangas
WHERE favorite = 1
AND source = :sourceId;

getReadMangaNotInLibrary:
SELECT *
FROM mangas m
WHERE m.favorite = 0 AND EXISTS (
    SELECT 1
    FROM chapters c
    WHERE c.manga_id = m._id AND (c.read = 1 OR c.last_page_read != 0)
    LIMIT 1
);

getAllManga:
SELECT *
FROM mangas;

getAllMangaSourceAndUrl:
SELECT source, url
FROM mangas;

getFavoriteSourceAndUrl:
SELECT source, url
FROM mangas
WHERE favorite = 1;

getMangasWithFavoriteTimestamp:
SELECT *
FROM mangas
WHERE favorite_modified_at IS NOT NULL;

getSourceIdWithFavoriteCount:
SELECT
source,
count(*)
FROM mangas
WHERE favorite = 1
GROUP BY source;

-- Get just unique source IDs from favorites - ultra-lightweight for extension listing
getFavoriteSourceIds:
SELECT DISTINCT source
FROM mangas
WHERE favorite = 1;

-- Lightweight query to get only genres for tag counting (avoids expensive libraryView JOIN)
getFavoriteGenres:
SELECT _id, genre
FROM mangas
WHERE favorite = 1;

-- Lightweight query to get genres with source ID for tag counting filtered by content type
getFavoriteGenresWithSource:
SELECT _id, source, genre
FROM mangas
WHERE favorite = 1;

-- Ultra-lightweight query for MassImport duplicate checking (only source + url)
-- Avoids expensive libraryView JOIN entirely
getFavoriteSourceAndUrlPairs:
SELECT source, url
FROM mangas
WHERE favorite = 1;

-- Ultra-lightweight query for URL matching in SettingsAdvancedScreen (only _id + url)
getFavoriteIdAndUrl:
SELECT _id, url
FROM mangas
WHERE favorite = 1;

-- Lightweight query for tag normalization (only _id + genre, avoids loading full Manga objects)
getFavoriteIdAndGenre:
SELECT _id, genre
FROM mangas
WHERE favorite = 1 AND genre IS NOT NULL AND genre != '';

getFavoriteBySourceId:
SELECT *
FROM mangas
WHERE favorite = 1
AND source = :sourceId;

getDuplicateLibraryManga:
SELECT M._id, M.source, M.url, M.artist, M.author, M.description, M.genre, M.title, M.alternative_titles, M.status, M.thumbnail_url, M.favorite, M.last_update, M.next_update, M.initialized, M.viewer, M.chapter_flags, M.cover_last_modified, M.date_added, M.update_strategy, M.calculate_interval, M.last_modified_at, M.favorite_modified_at, M.version, M.is_syncing, M.notes, M.is_novel,
  (SELECT COUNT(*) FROM chapters WHERE manga_id = M._id) AS totalCount,
  (SELECT COUNT(*) FROM chapters WHERE manga_id = M._id AND read = 1) AS readCount
FROM mangas M
WHERE M.favorite = 1
AND M._id != :id
AND lower(trim(M.title)) = lower(trim(:title))
LIMIT 10;

-- Get lightweight ID+title for all favorites (used for Kotlin-side contains comparison)
getFavoriteIdAndTitle:
SELECT _id, title
FROM mangas
WHERE favorite = 1;

-- Find all duplicate groups with exact match (case-insensitive, trimmed)
findDuplicatesExact:
SELECT
    lower(trim(title)) AS normalized_title,
    CAST(group_concat(_id) AS TEXT) AS ids,
    count(*) AS duplicate_count
FROM mangas
WHERE favorite = 1
GROUP BY lower(trim(title))
HAVING count(*) > 1
ORDER BY duplicate_count DESC;

-- Find all duplicate groups with contains match (one title contains another)
-- Optimized: use substr index and smaller comparisons to avoid full table scans
findDuplicatesContains:
SELECT
    a._id AS id_a,
    a.title AS title_a,
    b._id AS id_b,
    b.title AS title_b
FROM mangas a
JOIN mangas b
    ON a._id < b._id
   AND a.favorite = 1
   AND b.favorite = 1
   -- Filter by first character to reduce comparison set
   AND substr(lower(trim(a.title)), 1, 1) = substr(lower(trim(b.title)), 1, 1)
   -- Only check containment if lengths differ significantly
   AND (length(trim(a.title)) < length(trim(b.title)) * 0.8 OR length(trim(b.title)) < length(trim(a.title)) * 0.8)
   AND (lower(trim(b.title)) LIKE '%' || lower(trim(a.title)) || '%'
        OR lower(trim(a.title)) LIKE '%' || lower(trim(b.title)) || '%')
ORDER BY a.title
;

-- Find duplicates by URL within the same source/extension
findDuplicatesByUrl:
SELECT
    url,
    source,
    CAST(group_concat(_id) AS TEXT) AS ids,
    count(*) AS duplicate_count
FROM mangas
WHERE favorite = 1
GROUP BY url, source
HAVING count(*) > 1
ORDER BY duplicate_count DESC;

-- Get manga with chapter count for duplicate detection (optimized with JOIN)
getMangaWithCounts:
SELECT
    M._id, M.source, M.url, M.artist, M.author, M.description, M.genre, M.title, M.alternative_titles, M.status, M.thumbnail_url, M.favorite, M.last_update, M.next_update, M.initialized, M.viewer, M.chapter_flags, M.cover_last_modified, M.date_added, M.update_strategy, M.calculate_interval, M.last_modified_at, M.favorite_modified_at, M.version, M.is_syncing, M.notes, M.is_novel,
    COALESCE(CC.totalCount, 0) AS totalCount,
    COALESCE(CC.readCount, 0) AS readCount
FROM mangas M
LEFT JOIN (
    SELECT manga_id,
           COUNT(*) AS totalCount,
           SUM(CASE WHEN read = 1 THEN 1 ELSE 0 END) AS readCount
    FROM chapters
    WHERE manga_id IN :ids
    GROUP BY manga_id
) CC ON CC.manga_id = M._id
WHERE M._id IN :ids
ORDER BY totalCount DESC;

-- Lightweight version for duplicate detection: pushes :ids into chapters subquery
-- Uses same columns to keep SQLDelight column adapters working
getMangaWithCountsLight:
SELECT
    M._id, M.source, M.url, M.artist, M.author, M.description, M.genre, M.title, M.alternative_titles, M.status, M.thumbnail_url, M.favorite, M.last_update, M.next_update, M.initialized, M.viewer, M.chapter_flags, M.cover_last_modified, M.date_added, M.update_strategy, M.calculate_interval, M.last_modified_at, M.favorite_modified_at, M.version, M.is_syncing, M.notes, M.is_novel,
    COALESCE(CC.totalCount, 0) AS totalCount,
    COALESCE(CC.readCount, 0) AS readCount
FROM mangas M
LEFT JOIN (
    SELECT manga_id,
           COUNT(*) AS totalCount,
           SUM(CASE WHEN read = 1 THEN 1 ELSE 0 END) AS readCount
    FROM chapters
    WHERE manga_id IN :ids
    GROUP BY manga_id
) CC ON CC.manga_id = M._id
WHERE M._id IN :ids
ORDER BY totalCount DESC;

getUpcomingManga:
SELECT *
FROM mangas
WHERE next_update >= :startOfDay
AND favorite = 1
AND status IN :statuses
ORDER BY next_update ASC;

resetViewerFlags:
UPDATE mangas
SET viewer = 0;

resetIsSyncing:
UPDATE mangas
SET is_syncing = 0
WHERE is_syncing = 1;

getSourceIdsWithNonLibraryManga:
SELECT source, COUNT(*) AS manga_count
FROM mangas
WHERE favorite = 0
GROUP BY source;

deleteNonLibraryManga:
DELETE FROM mangas
WHERE favorite = 0
AND source IN :sourceIds
AND (
    :keepReadManga = 0
    OR _id NOT IN (
        SELECT DISTINCT manga_id
        FROM chapters
        WHERE read = 1
        OR last_page_read != 0
    )
);

deleteById:
DELETE FROM mangas
WHERE _id = :mangaId;

deleteByIds:
DELETE FROM mangas
WHERE _id IN :mangaIds;

insert:
INSERT INTO mangas(source, url, artist, author, description, genre, title, alternative_titles, status, thumbnail_url, favorite, last_update, next_update, initialized, viewer, chapter_flags, cover_last_modified, date_added, update_strategy, calculate_interval, last_modified_at, version, notes, is_novel)
VALUES (:source, :url, :artist, :author, :description, :genre, :title, :alternativeTitles, :status, :thumbnailUrl, :favorite, :lastUpdate, :nextUpdate, :initialized, :viewerFlags, :chapterFlags, :coverLastModified, :dateAdded, :updateStrategy, :calculateInterval, 0, :version, :notes, :isNovel);

update:
UPDATE mangas SET
    source = coalesce(:source, source),
    url = coalesce(:url, url),
    artist = coalesce(:artist, artist),
    author = coalesce(:author, author),
    description = coalesce(:description, description),
    genre = coalesce(:genre, genre),
    title = coalesce(:title, title),
    alternative_titles = coalesce(:alternativeTitles, alternative_titles),
    status = coalesce(:status, status),
    thumbnail_url = coalesce(:thumbnailUrl, thumbnail_url),
    favorite = coalesce(:favorite, favorite),
    last_update = coalesce(:lastUpdate, last_update),
    next_update = coalesce(:nextUpdate, next_update),
    initialized = coalesce(:initialized, initialized),
    viewer = coalesce(:viewer, viewer),
    chapter_flags = coalesce(:chapterFlags, chapter_flags),
    cover_last_modified = coalesce(:coverLastModified, cover_last_modified),
    date_added = coalesce(:dateAdded, date_added),
    update_strategy = coalesce(:updateStrategy, update_strategy),
    calculate_interval = coalesce(:calculateInterval, calculate_interval),
    version = coalesce(:version, version),
    is_syncing = coalesce(:isSyncing, is_syncing),
    notes = coalesce(:notes, notes),
    is_novel = coalesce(:isNovel, is_novel)
WHERE _id = :mangaId;

selectLastInsertedRowId:
SELECT last_insert_rowid();

-- Batch normalize URLs: remove trailing slashes and fragments
-- Returns count of updated rows
normalizeUrls:
UPDATE mangas
SET url =
    CASE
        WHEN instr(url, '#') > 0 THEN
            rtrim(substr(url, 1, instr(url, '#') - 1), '/')
        ELSE
            rtrim(url, '/')
    END
WHERE url LIKE '%/' OR url LIKE '%#%';

-- Batch normalize URLs with double slash removal
-- First removes trailing slashes and fragments, then removes double slashes (preserving protocol ://)
normalizeUrlsAdvanced:
UPDATE mangas
SET url =
    replace(
        replace(
            CASE
                WHEN instr(url, '#') > 0 THEN
                    rtrim(substr(url, 1, instr(url, '#') - 1), '/')
                ELSE
                    rtrim(url, '/')
            END,
            '://', '###PROTOCOL###'
        ),
        '//', '/'
    )
WHERE url LIKE '%/' OR url LIKE '%#%' OR url LIKE '%//%';

-- Fix protocol placeholder after normalizeUrlsAdvanced
fixProtocolPlaceholder:
UPDATE mangas
SET url = replace(url, '###PROTOCOL###', '://')
WHERE url LIKE '%###PROTOCOL###%';

-- Get potential duplicates after normalization (source, normalized_url pairs that would conflict)
getPotentialNormalizationDuplicates:
SELECT
    m1._id AS id1,
    m1.title AS title1,
    m1.url AS url1,
    m2._id AS id2,
    m2.title AS title2,
    m2.url AS url2,
    m1.source
FROM mangas m1
INNER JOIN mangas m2 ON m1.source = m2.source AND m1._id < m2._id
WHERE
    rtrim(
        CASE
            WHEN instr(m1.url, '#') > 0 THEN substr(m1.url, 1, instr(m1.url, '#') - 1)
            ELSE m1.url
        END,
        '/'
    ) = rtrim(
        CASE
            WHEN instr(m2.url, '#') > 0 THEN substr(m2.url, 1, instr(m2.url, '#') - 1)
            ELSE m2.url
        END,
        '/'
    );

insertNetworkManga {
    -- Insert the manga if it doesn't exist already
    INSERT INTO mangas(
        source, url, artist, author, description, genre, title, alternative_titles, status, thumbnail_url, favorite,
        last_update, next_update, initialized, viewer, chapter_flags, cover_last_modified, date_added,
        update_strategy, calculate_interval, last_modified_at, version, is_novel
    )
    SELECT
        :source, :url, :artist, :author, :description, :genre, :title, :alternativeTitles, :status, :thumbnailUrl, :favorite,
        :lastUpdate, :nextUpdate, :initialized, :viewerFlags, :chapterFlags, :coverLastModified, :dateAdded,
        :updateStrategy, :calculateInterval, 0, :version, :isNovel
    WHERE NOT EXISTS(SELECT 0 FROM mangas WHERE source = :source AND url = :url);

    -- Update the relevant details if applicable and not favorite
    UPDATE mangas
    SET
        title = CASE WHEN :updateTitle THEN :title ELSE title END,
        thumbnail_url = CASE WHEN :updateCover THEN :thumbnailUrl ELSE thumbnail_url END,
        author = CASE WHEN :updateDetails THEN :author ELSE author END,
        artist = CASE WHEN :updateDetails THEN :artist ELSE artist END,
        description = CASE WHEN :updateDetails THEN :description ELSE description END,
        genre = CASE WHEN :updateDetails THEN :genre ELSE genre END,
        alternative_titles = CASE WHEN :updateDetails THEN :alternativeTitles ELSE alternative_titles END,
        status = CASE WHEN :updateDetails THEN :status ELSE status END,
        update_strategy = CASE WHEN :updateDetails THEN :updateStrategy ELSE update_strategy END,
        initialized = :updateDetails,
        is_novel = :isNovel
    WHERE source = :source
    AND url = :url
    AND favorite = 0;

    -- Finally return the manga
    SELECT *
    FROM mangas
    WHERE source = :source
    AND url = :url
    LIMIT 1;
}

-- ==== Library queries (aggregates stored directly on mangas table) ====

libraryGrid:
SELECT
    M._id,
    M.source,
    M.url,
    NULL AS artist,
    NULL AS author,
    NULL AS description,
    M.genre,
    M.title,
    NULL AS alternative_titles,
    M.status,
    M.thumbnail_url,
    M.favorite,
    M.last_update,
    M.next_update,
    0 AS initialized,
    0 AS viewer,
    0 AS chapter_flags,
    M.cover_last_modified,
    M.date_added,
    0 AS update_strategy,
    M.calculate_interval,
    0 AS last_modified_at,
    NULL AS favorite_modified_at,
    0 AS version,
    0 AS is_syncing,
    '' AS notes,
    M.is_novel,
    M.total_count AS totalCount,
    CAST(M.read_count AS REAL) AS readCount,
    M.latest_upload AS latestUpload,
    M.chapter_fetched_at AS chapterFetchedAt,
    M.last_read AS lastRead,
    CAST(M.bookmark_count AS REAL) AS bookmarkCount,
    coalesce(MC.categories, '0') AS categories
FROM mangas M
LEFT JOIN (
    SELECT manga_id, group_concat(category_id) AS categories
    FROM mangas_categories
    GROUP BY manga_id
) AS MC ON MC.manga_id = M._id
WHERE M.favorite = 1;

-- Fetch a single library item by manga ID
libraryGridById:
SELECT
    M._id,
    M.source,
    M.url,
    NULL AS artist,
    NULL AS author,
    NULL AS description,
    M.genre,
    M.title,
    NULL AS alternative_titles,
    M.status,
    M.thumbnail_url,
    M.favorite,
    M.last_update,
    M.next_update,
    0 AS initialized,
    0 AS viewer,
    0 AS chapter_flags,
    M.cover_last_modified,
    M.date_added,
    0 AS update_strategy,
    M.calculate_interval,
    0 AS last_modified_at,
    NULL AS favorite_modified_at,
    0 AS version,
    0 AS is_syncing,
    '' AS notes,
    M.is_novel,
    M.total_count AS totalCount,
    CAST(M.read_count AS REAL) AS readCount,
    M.latest_upload AS latestUpload,
    M.chapter_fetched_at AS chapterFetchedAt,
    M.last_read AS lastRead,
    CAST(M.bookmark_count AS REAL) AS bookmarkCount,
    coalesce(MC.categories, '0') AS categories
FROM mangas M
LEFT JOIN (
    SELECT manga_id, group_concat(category_id) AS categories
    FROM mangas_categories
    WHERE manga_id = :mangaId
    GROUP BY manga_id
) AS MC ON MC.manga_id = M._id
WHERE M._id = :mangaId AND M.favorite = 1;

libraryGridByIds:
SELECT
    M._id,
    M.source,
    M.url,
    NULL AS artist,
    NULL AS author,
    NULL AS description,
    M.genre,
    M.title,
    NULL AS alternative_titles,
    M.status,
    M.thumbnail_url,
    M.favorite,
    M.last_update,
    M.next_update,
    0 AS initialized,
    0 AS viewer,
    0 AS chapter_flags,
    M.cover_last_modified,
    M.date_added,
    0 AS update_strategy,
    M.calculate_interval,
    0 AS last_modified_at,
    NULL AS favorite_modified_at,
    0 AS version,
    0 AS is_syncing,
    '' AS notes,
    M.is_novel,
    M.total_count AS totalCount,
    CAST(M.read_count AS REAL) AS readCount,
    M.latest_upload AS latestUpload,
    M.chapter_fetched_at AS chapterFetchedAt,
    M.last_read AS lastRead,
    CAST(M.bookmark_count AS REAL) AS bookmarkCount,
    coalesce(MC.categories, '0') AS categories
FROM mangas M
LEFT JOIN (
    SELECT manga_id, group_concat(category_id) AS categories
    FROM mangas_categories
    WHERE manga_id IN :mangaIds
    GROUP BY manga_id
) AS MC ON MC.manga_id = M._id
WHERE M._id IN :mangaIds AND M.favorite = 1;

libraryForUpdate:
SELECT
    M._id,
    M.source,
    M.url,
    M.title,
    M.status,
    M.favorite,
    M.last_update,
    M.next_update,
    M.update_strategy,
    M.total_count AS totalCount,
    CAST(M.read_count AS REAL) AS readCount,
    coalesce(MC.categories, '0') AS categories
FROM mangas M
LEFT JOIN (
    SELECT manga_id, group_concat(category_id) AS categories
    FROM mangas_categories
    GROUP BY manga_id
) AS MC ON MC.manga_id = M._id
WHERE M.favorite = 1;

recomputeAggregatesForManga:
UPDATE mangas
SET
    total_count = (
        SELECT count(*)
        FROM chapters
        LEFT JOIN excluded_scanlators ON chapters.manga_id = excluded_scanlators.manga_id
            AND chapters.scanlator = excluded_scanlators.scanlator
        WHERE chapters.manga_id = :mangaId AND excluded_scanlators.scanlator IS NULL
    ),
    read_count = (
        SELECT coalesce(sum(chapters.read), 0)
        FROM chapters
        LEFT JOIN excluded_scanlators ON chapters.manga_id = excluded_scanlators.manga_id
            AND chapters.scanlator = excluded_scanlators.scanlator
        WHERE chapters.manga_id = :mangaId AND excluded_scanlators.scanlator IS NULL
    ),
    latest_upload = (
        SELECT coalesce(max(chapters.date_upload), 0)
        FROM chapters
        LEFT JOIN excluded_scanlators ON chapters.manga_id = excluded_scanlators.manga_id
            AND chapters.scanlator = excluded_scanlators.scanlator
        WHERE chapters.manga_id = :mangaId AND excluded_scanlators.scanlator IS NULL
    ),
    chapter_fetched_at = (
        SELECT coalesce(max(chapters.date_fetch), 0)
        FROM chapters
        LEFT JOIN excluded_scanlators ON chapters.manga_id = excluded_scanlators.manga_id
            AND chapters.scanlator = excluded_scanlators.scanlator
        WHERE chapters.manga_id = :mangaId AND excluded_scanlators.scanlator IS NULL
    ),
    last_read = (
        SELECT coalesce(max(history.last_read), 0)
        FROM chapters
        LEFT JOIN excluded_scanlators ON chapters.manga_id = excluded_scanlators.manga_id
            AND chapters.scanlator = excluded_scanlators.scanlator
        LEFT JOIN history ON chapters._id = history.chapter_id
        WHERE chapters.manga_id = :mangaId AND excluded_scanlators.scanlator IS NULL
    ),
    bookmark_count = (
        SELECT coalesce(sum(chapters.bookmark), 0)
        FROM chapters
        LEFT JOIN excluded_scanlators ON chapters.manga_id = excluded_scanlators.manga_id
            AND chapters.scanlator = excluded_scanlators.scanlator
        WHERE chapters.manga_id = :mangaId AND excluded_scanlators.scanlator IS NULL
    )
WHERE _id = :mangaId;

recomputeAllAggregates:
UPDATE mangas
SET
    total_count = coalesce((
        SELECT count(*)
        FROM chapters
        LEFT JOIN excluded_scanlators ON chapters.manga_id = excluded_scanlators.manga_id
            AND chapters.scanlator = excluded_scanlators.scanlator
        WHERE chapters.manga_id = mangas._id AND excluded_scanlators.scanlator IS NULL
    ), 0),
    read_count = coalesce((
        SELECT sum(chapters.read)
        FROM chapters
        LEFT JOIN excluded_scanlators ON chapters.manga_id = excluded_scanlators.manga_id
            AND chapters.scanlator = excluded_scanlators.scanlator
        WHERE chapters.manga_id = mangas._id AND excluded_scanlators.scanlator IS NULL
    ), 0),
    latest_upload = coalesce((
        SELECT max(chapters.date_upload)
        FROM chapters
        LEFT JOIN excluded_scanlators ON chapters.manga_id = excluded_scanlators.manga_id
            AND chapters.scanlator = excluded_scanlators.scanlator
        WHERE chapters.manga_id = mangas._id AND excluded_scanlators.scanlator IS NULL
    ), 0),
    chapter_fetched_at = coalesce((
        SELECT max(chapters.date_fetch)
        FROM chapters
        LEFT JOIN excluded_scanlators ON chapters.manga_id = excluded_scanlators.manga_id
            AND chapters.scanlator = excluded_scanlators.scanlator
        WHERE chapters.manga_id = mangas._id AND excluded_scanlators.scanlator IS NULL
    ), 0),
    last_read = coalesce((
        SELECT max(history.last_read)
        FROM chapters
        LEFT JOIN excluded_scanlators ON chapters.manga_id = excluded_scanlators.manga_id
            AND chapters.scanlator = excluded_scanlators.scanlator
        LEFT JOIN history ON chapters._id = history.chapter_id
        WHERE chapters.manga_id = mangas._id AND excluded_scanlators.scanlator IS NULL
    ), 0),
    bookmark_count = coalesce((
        SELECT sum(chapters.bookmark)
        FROM chapters
        LEFT JOIN excluded_scanlators ON chapters.manga_id = excluded_scanlators.manga_id
            AND chapters.scanlator = excluded_scanlators.scanlator
        WHERE chapters.manga_id = mangas._id AND excluded_scanlators.scanlator IS NULL
    ), 0)
WHERE favorite = 1;
