-- History cache table - maintained by triggers for fast reads
-- Triggers keep this in sync with history/chapters/mangas tables

import java.util.Date;
import kotlin.Boolean;

CREATE TABLE history_cache (
    _id INTEGER NOT NULL PRIMARY KEY,
    manga_id INTEGER NOT NULL,
    chapter_id INTEGER NOT NULL,
    manga_title TEXT NOT NULL,
    manga_thumbnail_url TEXT,
    manga_source INTEGER NOT NULL,
    manga_favorite INTEGER AS Boolean NOT NULL,
    manga_cover_last_modified INTEGER NOT NULL,
    chapter_number REAL NOT NULL,
    last_read INTEGER NOT NULL,
    time_read INTEGER NOT NULL,
    FOREIGN KEY(chapter_id) REFERENCES chapters(_id) ON DELETE CASCADE,
    FOREIGN KEY(manga_id) REFERENCES mangas(_id) ON DELETE CASCADE
);

CREATE INDEX history_cache_last_read_idx ON history_cache(last_read DESC);
CREATE INDEX history_cache_manga_id_idx ON history_cache(manga_id);

getHistoryWithSearch:
SELECT
    _id AS id,
    manga_id AS mangaId,
    chapter_id AS chapterId,
    manga_title AS title,
    manga_thumbnail_url AS thumbnailUrl,
    manga_source AS source,
    manga_favorite AS favorite,
    manga_cover_last_modified AS cover_last_modified,
    chapter_number AS chapterNumber,
    last_read AS readAt,
    time_read AS readDuration
FROM history_cache
WHERE last_read > 0
AND lower(manga_title) LIKE ('%' || :query || '%')
ORDER BY last_read DESC
LIMIT 1000;

getLatestHistoryCache:
SELECT
    _id AS id,
    manga_id AS mangaId,
    chapter_id AS chapterId,
    manga_title AS title,
    manga_thumbnail_url AS thumbnailUrl,
    manga_source AS source,
    manga_favorite AS favorite,
    manga_cover_last_modified AS cover_last_modified,
    chapter_number AS chapterNumber,
    last_read AS readAt,
    time_read AS readDuration
FROM history_cache
WHERE last_read > 0
ORDER BY last_read DESC
LIMIT 1;

rebuildHistoryCacheLimited:
INSERT OR REPLACE INTO history_cache (
    _id, manga_id, chapter_id, manga_title, manga_thumbnail_url,
    manga_source, manga_favorite, manga_cover_last_modified,
    chapter_number, last_read, time_read
)
SELECT
    history._id, mangas._id, chapters._id, mangas.title, mangas.thumbnail_url,
    mangas.source, mangas.favorite, mangas.cover_last_modified,
    chapters.chapter_number, CAST(history.last_read AS INTEGER), history.time_read
FROM history
JOIN chapters ON chapters._id = history.chapter_id
JOIN mangas ON mangas._id = chapters.manga_id
WHERE history.last_read > 0
ORDER BY history.last_read DESC
LIMIT 1000;

clearAll:
DELETE FROM history_cache;
