-- Updates cache table - maintained by triggers for fast reads
-- Triggers keep this in sync with mangas/chapters tables

import kotlin.Boolean;

CREATE TABLE updates_cache (
    manga_id INTEGER NOT NULL,
    manga_title TEXT NOT NULL,
    chapter_id INTEGER NOT NULL PRIMARY KEY,
    chapter_name TEXT NOT NULL,
    scanlator TEXT,
    chapter_url TEXT NOT NULL,
    read INTEGER AS Boolean NOT NULL,
    bookmark INTEGER AS Boolean NOT NULL,
    last_page_read INTEGER NOT NULL,
    source INTEGER NOT NULL,
    favorite INTEGER AS Boolean NOT NULL,
    thumbnail_url TEXT,
    cover_last_modified INTEGER NOT NULL,
    date_upload INTEGER NOT NULL,
    date_fetch INTEGER NOT NULL,
    FOREIGN KEY(chapter_id) REFERENCES chapters(_id) ON DELETE CASCADE,
    FOREIGN KEY(manga_id) REFERENCES mangas(_id) ON DELETE CASCADE
);

CREATE INDEX updates_cache_date_fetch_idx ON updates_cache(date_fetch DESC);
CREATE INDEX updates_cache_manga_id_idx ON updates_cache(manga_id);
CREATE INDEX updates_cache_read_date_idx ON updates_cache(read, date_upload);


-- Get recent updates
getRecentUpdates:
SELECT
    manga_id AS mangaId,
    manga_title AS mangaTitle,
    chapter_id AS chapterId,
    chapter_name AS chapterName,
    scanlator,
    chapter_url AS chapterUrl,
    read,
    bookmark,
    last_page_read,
    source,
    favorite,
    thumbnail_url AS thumbnailUrl,
    cover_last_modified AS coverLastModified,
    date_upload AS dateUpload,
    date_fetch AS datefetch
FROM updates_cache
WHERE date_upload > :after
ORDER BY date_fetch DESC
LIMIT :limit;

-- Get updates by read status
getUpdatesByReadStatus:
SELECT
    manga_id AS mangaId,
    manga_title AS mangaTitle,
    chapter_id AS chapterId,
    chapter_name AS chapterName,
    scanlator,
    chapter_url AS chapterUrl,
    read,
    bookmark,
    last_page_read,
    source,
    favorite,
    thumbnail_url AS thumbnailUrl,
    cover_last_modified AS coverLastModified,
    date_upload AS dateUpload,
    date_fetch AS datefetch
FROM updates_cache
WHERE read = :read
AND date_upload > :after
ORDER BY date_fetch DESC
LIMIT :limit;

-- Count entries
countAll:
SELECT COUNT(*) FROM updates_cache;

-- Rebuild cache
rebuildUpdatesCacheLimited:
INSERT OR IGNORE INTO updates_cache (
    manga_id, manga_title, chapter_id, chapter_name, scanlator,
    chapter_url, read, bookmark, last_page_read, source,
    favorite, thumbnail_url, cover_last_modified, date_upload, date_fetch
)
SELECT
    mangas._id, mangas.title, chapters._id, chapters.name, chapters.scanlator,
    chapters.url, chapters.read, chapters.bookmark, chapters.last_page_read, mangas.source,
    1, mangas.thumbnail_url, mangas.cover_last_modified, chapters.date_upload, chapters.date_fetch
FROM mangas
JOIN chapters ON mangas._id = chapters.manga_id
WHERE mangas.favorite = 1
AND chapters.date_fetch > mangas.date_added
ORDER BY chapters.date_fetch DESC
LIMIT 1000;

-- Clear all entries
clearAll:
DELETE FROM updates_cache;

-- Clear entries older than a date
clearOlderThan:
DELETE FROM updates_cache WHERE date_fetch < :before;
